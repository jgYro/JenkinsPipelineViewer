<!doctype html>
<html>
  <head>
    <title>Build Pipeline - Real Time</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        background-color: #f5f5f5;
      }

      h1 {
        background-color: #2c3e50;
        color: white;
        padding: 20px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
      }

      .header-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: absolute;
        left: 20px;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
      }

      .build-info {
        display: flex;
        align-items: center;
        gap: 15px;
        font-size: 14px;
      }

      .build-selector {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .build-selector select {
        padding: 6px 10px;
        border-radius: 4px;
        border: 1px solid #34495e;
        background: #34495e;
        color: white;
        font-size: 14px;
        cursor: pointer;
      }

      .build-selector select:hover {
        background: #445566;
      }

      .current-build-status {
        padding: 4px 12px;
        border-radius: 4px;
        font-size: 13px;
        font-weight: 500;
      }

      .build-status-success {
        background-color: rgba(40, 167, 69, 0.2);
        color: #28a745;
      }

      .build-status-failed {
        background-color: rgba(220, 53, 69, 0.2);
        color: #dc3545;
      }

      .build-status-in_progress,
      .build-status-running {
        background-color: rgba(0, 123, 255, 0.2);
        color: #007bff;
      }

      .connection-status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }

      .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #dc3545;
      }

      .status-indicator.connected {
        background-color: #28a745;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
        }
      }

      .new-build-alert {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: #007bff;
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        animation: slideDown 0.5s ease-out;
        display: none;
      }

      .new-build-alert.show {
        display: block;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translate(-50%, -20px);
        }
        to {
          opacity: 1;
          transform: translate(-50%, 0);
        }
      }

      .pipeline-container {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 15px;
        max-width: 1400px;
        width: 100%;
        margin: 0 auto;
      }

      .run-header {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 10px;
      }

      .run-header h2 {
        font-size: 20px;
        margin-bottom: 10px;
        color: #2c3e50;
      }

      .run-details {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        font-size: 14px;
        color: #666;
      }

      .run-detail-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .run-detail-label {
        font-weight: 600;
        color: #444;
      }

      details {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.3s;
      }

      details.updating {
        box-shadow: 0 0 0 2px #2196f3;
      }

      details:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      summary {
        padding: 20px 25px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        list-style: none;
        font-size: 18px;
        font-weight: 500;
        background-color: white;
        border-radius: 8px;
        user-select: none;
      }

      summary:hover {
        background-color: #f8f9fa;
      }

      summary::-webkit-details-marker {
        display: none;
      }

      summary::before {
        content: "▶";
        margin-right: 15px;
        transition: transform 0.3s;
        color: #666;
      }

      details[open] summary::before {
        transform: rotate(90deg);
      }

      details[open] summary {
        border-radius: 8px 8px 0 0;
        border-bottom: 1px solid #e0e0e0;
      }

      .stage-info {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .stage-duration {
        font-size: 14px;
        color: #666;
      }

      .auto-scroll-indicator {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 123, 255, 0.9);
        color: white;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        display: none;
        align-items: center;
        gap: 6px;
        z-index: 10;
        cursor: pointer;
      }

      .auto-scroll-indicator.active {
        display: flex;
      }

      .auto-scroll-indicator::before {
        content: "⬇";
        animation: bounce 1s infinite;
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-3px);
        }
      }

      details[data-stage-status="in_progress"] .stage-content,
      details[data-stage-status="running"] .stage-content {
        position: relative;
      }

      .stage-status {
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        transition: all 0.3s;
      }

      .status-success {
        background-color: #d4edda;
        color: #155724;
      }

      .status-failed {
        background-color: #f8d7da;
        color: #721c24;
      }

      .status-in_progress,
      .status-running {
        background-color: #cce5ff;
        color: #004085;
        position: relative;
        overflow: hidden;
      }

      .status-in_progress::after,
      .status-running::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        to {
          left: 100%;
        }
      }

      .status-pending,
      .status-paused {
        background-color: #fff3cd;
        color: #856404;
      }

      .stage-content {
        padding: 0;
        max-height: 400px;
        overflow-y: auto;
        background-color: #fafafa;
        border-radius: 0 0 8px 8px;
      }

      .stage-content::-webkit-scrollbar {
        width: 8px;
      }

      .stage-content::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 0 0 8px 0;
      }

      .stage-content::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }

      .stage-content::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      .stage-content ul {
        list-style: none;
        padding: 20px;
      }

      .stage-content li {
        background: white;
        padding: 15px 20px;
        margin-bottom: 12px;
        border-radius: 6px;
        border-left: 4px solid #2196f3;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        transition: all 0.3s;
      }

      .stage-content li.new-item {
        animation: slideIn 0.5s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .stage-content li:last-child {
        margin-bottom: 0;
      }

      .step-name {
        font-weight: 600;
        color: #2c3e50;
        font-size: 16px;
        margin-bottom: 8px;
      }

      .step-info {
        color: #666;
        font-size: 14px;
        line-height: 1.6;
      }

      .step-info em {
        font-style: normal;
        font-weight: 500;
        color: #444;
      }

      .no-stages {
        text-align: center;
        padding: 40px;
        color: #666;
        font-size: 18px;
      }

      /* Make it responsive */
      @media (max-width: 768px) {
        .pipeline-container {
          padding: 10px;
        }

        summary {
          padding: 15px 20px;
          font-size: 16px;
        }

        .stage-content {
          max-height: 300px;
        }

        .header-controls {
          position: static;
          transform: none;
          flex-direction: column;
          margin-top: 10px;
          gap: 10px;
        }

        h1 {
          padding-bottom: 60px;
        }

        .run-details {
          grid-template-columns: 1fr;
        }
      }
    </style>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  </head>
  <body>
    <h1>
      Build Steps Overview
      <div class="header-controls">
        <div class="build-info">
          <div class="build-selector">
            <label for="build-select">Build:</label>
            <select id="build-select">
              <!-- Will be populated dynamically -->
            </select>
          </div>
          <div
            class="current-build-status build-status-{{ runInfo.status|lower }}"
            id="current-build-status"
          >
            {{ runInfo.status }}
          </div>
        </div>
        <div class="connection-status">
          <div class="status-indicator" id="connection-indicator"></div>
          <span id="connection-text">Disconnected</span>
        </div>
      </div>
    </h1>

    <div class="new-build-alert" id="new-build-alert">
      <strong>New build started!</strong> Click here to view it or use the build
      selector.
    </div>

    <div class="pipeline-container" id="pipeline-container">
      <div class="run-header" id="run-header">
        <h2>Build #<span id="run-name">{{ runInfo.name }}</span></h2>
        <div class="run-details">
          <div class="run-detail-item">
            <span class="run-detail-label">Started:</span>
            <span id="run-start-time">-</span>
          </div>
          <div class="run-detail-item">
            <span class="run-detail-label">Duration:</span>
            <span id="run-duration">-</span>
          </div>
          <div class="run-detail-item">
            <span class="run-detail-label">Trigger:</span>
            <span id="run-trigger">{{ runInfo.causesString or 'Manual' }}</span>
          </div>
          <div class="run-detail-item">
            <span class="run-detail-label">Last Update:</span>
            <span id="last-update-time">-</span>
          </div>
        </div>
      </div>

      <div id="stages-container">
        {% if stages %} {% for stage in stages %}
        <details
          data-stage-name="{{ stage.name }}"
          data-stage-status="{{ stage.status|lower }}"
        >
          <summary>
            <span>{{ stage.name }}</span>
            <div class="stage-info">
              <span
                class="stage-duration"
                data-start="{{ stage.startTimeMillis }}"
                data-duration="{{ stage.durationMillis }}"
                >-</span
              >
              <span class="stage-status status-{{ stage.status|lower }}"
                >{{ stage.status }}</span
              >
            </div>
          </summary>
          <div class="stage-content">
            <ul>
              {% for step in stage.stageFlowNodes %}
              <li data-step-name="{{ step.name }}">
                <div class="step-name">{{ step.name }}</div>
                <div class="step-info">
                  <em>Status:</em>
                  <span class="step-status">{{ step.status }}</span><br />
                  <em>Description:</em>
                  <span class="step-description"
                    >{{ step.parameterDescription or 'N/A' }}</span
                  >
                </div>
              </li>
              {% endfor %}
            </ul>
            {% if stage.status|lower in ['in_progress', 'running'] %}
            <div class="auto-scroll-indicator">Auto-scroll</div>
            {% endif %}
          </div>
        </details>
        {% endfor %} {% else %}
        <div class="no-stages">No pipeline stages available</div>
        {% endif %}
      </div>
    </div>

    <script>
      // Initialize Socket.IO connection
      const socket = io();

      // Track state
      const openDetails = new Set();
      const tailingStages = new Set();
      let currentRunId = '{{ runInfo.id }}';
      let isViewingLatest = true;

      // DOM elements
      const connectionIndicator = document.getElementById('connection-indicator');
      const connectionText = document.getElementById('connection-text');
      const lastUpdateTime = document.getElementById('last-update-time');
      const buildSelect = document.getElementById('build-select');
      const newBuildAlert = document.getElementById('new-build-alert');
      const runHeader = document.getElementById('run-header');
      const stagesContainer = document.getElementById('stages-container');

      // Utility functions
      function formatDuration(millis) {
        if (!millis) return '-';
        const seconds = Math.floor(millis / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);

        if (hours > 0) {
          return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        } else if (minutes > 0) {
          return `${minutes}m ${seconds % 60}s`;
        } else {
          return `${seconds}s`;
        }
      }

      function formatTimestamp(millis) {
        if (!millis) return '-';
        const date = new Date(millis);
        return date.toLocaleString();
      }

      function updateConnectionStatus(connected) {
        if (connected) {
          connectionIndicator.classList.add('connected');
          connectionText.textContent = 'Connected';
        } else {
          connectionIndicator.classList.remove('connected');
          connectionText.textContent = 'Disconnected';
        }
      }

      function updateLastUpdateTime() {
        const now = new Date();
        lastUpdateTime.textContent = now.toLocaleTimeString();
      }

      // Save/restore details state
      function saveDetailsState() {
        openDetails.clear();
        document.querySelectorAll('details[open]').forEach(details => {
          const stageName = details.getAttribute('data-stage-name');
          if (stageName) {
            openDetails.add(stageName);
          }
        });
      }

      function restoreDetailsState() {
        document.querySelectorAll('details').forEach(details => {
          const stageName = details.getAttribute('data-stage-name');
          if (stageName && openDetails.has(stageName)) {
            details.open = true;
          }
        });
      }

      // Update build selector
      function updateBuildSelector(recentRuns, currentId) {
        buildSelect.innerHTML = recentRuns.map(run => {
          const duration = formatDuration(run.durationMillis);
          const isSelected = run.id === currentId ? 'selected' : '';
          const status = run.status.toLowerCase();
          return `<option value="${run.id}" ${isSelected} data-status="${status}">
            #${run.name} - ${run.status} ${duration !== '-' ? `(${duration})` : ''}
          </option>`;
        }).join('');
      }

      // Update run header
      function updateRunHeader(runInfo) {
        document.getElementById('run-name').textContent = runInfo.name || '-';
        document.getElementById('run-start-time').textContent = formatTimestamp(runInfo.startTimeMillis);
        document.getElementById('run-duration').textContent = formatDuration(runInfo.durationMillis);
        document.getElementById('run-trigger').textContent = runInfo.causesString || 'Manual';

        // Update status badge
        const statusBadge = document.getElementById('current-build-status');
        statusBadge.className = `current-build-status build-status-${runInfo.status.toLowerCase()}`;
        statusBadge.textContent = runInfo.status;
      }

      // Update stage durations
      function updateStageDurations() {
        document.querySelectorAll('.stage-duration').forEach(elem => {
          const duration = elem.getAttribute('data-duration');
          elem.textContent = formatDuration(duration);
        });
      }

      // Attach scroll listeners and handlers
      function attachScrollHandlers(stageContent, stageName, isInProgress) {
        // Remove existing listeners to avoid duplicates
        const existingHandler = stageContent._scrollHandler;
        if (existingHandler) {
          stageContent.removeEventListener('scroll', existingHandler);
        }

        const scrollHandler = function() {
          const isAtBottom = this.scrollHeight - this.scrollTop - this.clientHeight < 5;
          const indicator = this.querySelector('.auto-scroll-indicator');

          if (!isAtBottom) {
            tailingStages.delete(stageName);
            if (indicator) indicator.classList.remove('active');
          } else if (isInProgress) {
            tailingStages.add(stageName);
            if (indicator) indicator.classList.add('active');
          }
        };

        stageContent._scrollHandler = scrollHandler;
        stageContent.addEventListener('scroll', scrollHandler);

        // Handle auto-scroll indicator
        const indicator = stageContent.querySelector('.auto-scroll-indicator');
        if (indicator) {
          // Remove existing click handler
          if (indicator._clickHandler) {
            indicator.removeEventListener('click', indicator._clickHandler);
          }

          const clickHandler = function() {
            stageContent.scrollTop = stageContent.scrollHeight;
            tailingStages.add(stageName);
            this.classList.add('active');
          };

          indicator._clickHandler = clickHandler;
          indicator.addEventListener('click', clickHandler);

          // Update visibility
          if (tailingStages.has(stageName)) {
            indicator.classList.add('active');
          } else {
            indicator.classList.remove('active');
          }
        }
      }

      // Update the pipeline display - more efficient version
      function updatePipeline(data) {
        saveDetailsState();

        // Update run info
        if (data.runInfo) {
          currentRunId = data.runInfo.id;
          updateRunHeader(data.runInfo);
        }

        // Update build selector if we have recent runs
        if (data.recentRuns) {
          updateBuildSelector(data.recentRuns, currentRunId);
          isViewingLatest = data.recentRuns[0] && data.recentRuns[0].id === currentRunId;
        }

        // Show new build alert if this is a new build and we're not viewing it
        if (data.isNewBuild && !isViewingLatest) {
          newBuildAlert.classList.add('show');
          setTimeout(() => {
            newBuildAlert.classList.remove('show');
          }, 5000);
        }

        // Update stages
        if (!data.stages || data.stages.length === 0) {
          stagesContainer.innerHTML = '<div class="no-stages">No pipeline stages available</div>';
          return;
        }

        // Create a map of existing stages
        const existingStages = new Map();
        stagesContainer.querySelectorAll('details').forEach(details => {
          const stageName = details.getAttribute('data-stage-name');
          if (stageName) {
            existingStages.set(stageName, details);
          }
        });

        // Update or create stages
        data.stages.forEach((stage, index) => {
          const existingStage = existingStages.get(stage.name);
          const isInProgress = stage.status.toLowerCase() === 'in_progress' ||
                              stage.status.toLowerCase() === 'running';

          if (existingStage) {
            // Update existing stage
            existingStages.delete(stage.name); // Mark as processed

            // Save scroll position
            const stageContent = existingStage.querySelector('.stage-content');
            const wasAtBottom = stageContent &&
              (stageContent.scrollHeight - stageContent.scrollTop - stageContent.clientHeight < 5);
            const scrollTop = stageContent ? stageContent.scrollTop : 0;

            // Update stage status
            existingStage.setAttribute('data-stage-status', stage.status.toLowerCase());

            // Update summary
            const statusElem = existingStage.querySelector('.stage-status');
            if (statusElem) {
              statusElem.className = `stage-status status-${stage.status.toLowerCase()}`;
              statusElem.textContent = stage.status;
            }

            const durationElem = existingStage.querySelector('.stage-duration');
            if (durationElem) {
              durationElem.setAttribute('data-duration', stage.durationMillis || '');
              durationElem.textContent = formatDuration(stage.durationMillis);
            }

            // Update steps more efficiently
            if (stageContent) {
              const stepsList = stageContent.querySelector('ul');
              if (stepsList) {
                // Create a map of existing steps
                const existingSteps = new Map();
                stepsList.querySelectorAll('li').forEach(li => {
                  const stepName = li.getAttribute('data-step-name');
                  if (stepName) {
                    existingSteps.set(stepName, li);
                  }
                });

                // Update or add steps
                stage.stageFlowNodes.forEach(step => {
                  const existingStep = existingSteps.get(step.name);

                  if (existingStep) {
                    // Update existing step
                    existingSteps.delete(step.name);
                    const statusSpan = existingStep.querySelector('.step-status');
                    const descSpan = existingStep.querySelector('.step-description');

                    if (statusSpan) statusSpan.textContent = step.status;
                    if (descSpan) descSpan.textContent = step.parameterDescription || 'N/A';
                  } else {
                    // Add new step
                    const newStep = document.createElement('li');
                    newStep.setAttribute('data-step-name', step.name);
                    newStep.className = 'new-item';
                    newStep.innerHTML = `
                      <div class="step-name">${step.name}</div>
                      <div class="step-info">
                        <em>Status:</em> <span class="step-status">${step.status}</span><br />
                        <em>Description:</em> <span class="step-description">${step.parameterDescription || 'N/A'}</span>
                      </div>
                    `;
                    stepsList.appendChild(newStep);
                  }
                });

                // Remove steps that no longer exist
                existingSteps.forEach(step => step.remove());
              }

              // Handle auto-scroll indicator
              let indicator = stageContent.querySelector('.auto-scroll-indicator');
              if (isInProgress && !indicator) {
                // Add indicator
                indicator = document.createElement('div');
                indicator.className = 'auto-scroll-indicator';
                indicator.textContent = 'Auto-scroll';
                stageContent.appendChild(indicator);
              } else if (!isInProgress && indicator) {
                // Remove indicator
                indicator.remove();
              }

              // Restore scroll position or tail
              if (isInProgress && (tailingStages.has(stage.name) || wasAtBottom)) {
                stageContent.scrollTop = stageContent.scrollHeight;
                tailingStages.add(stage.name);
              } else {
                stageContent.scrollTop = scrollTop;
              }

              // Attach scroll handlers
              attachScrollHandlers(stageContent, stage.name, isInProgress);
            }
          } else {
            // Create new stage
            const newStage = document.createElement('details');
            newStage.setAttribute('data-stage-name', stage.name);
            newStage.setAttribute('data-stage-status', stage.status.toLowerCase());

            newStage.innerHTML = `
              <summary>
                <span>${stage.name}</span>
                <div class="stage-info">
                  <span class="stage-duration" data-start="${stage.startTimeMillis || ''}" data-duration="${stage.durationMillis || ''}">${formatDuration(stage.durationMillis)}</span>
                  <span class="stage-status status-${stage.status.toLowerCase()}">${stage.status}</span>
                </div>
              </summary>
              <div class="stage-content">
                <ul>
                  ${stage.stageFlowNodes.map(step => `
                    <li data-step-name="${step.name}">
                      <div class="step-name">${step.name}</div>
                      <div class="step-info">
                        <em>Status:</em> <span class="step-status">${step.status}</span><br />
                        <em>Description:</em> <span class="step-description">${step.parameterDescription || 'N/A'}</span>
                      </div>
                    </li>
                  `).join('')}
                </ul>
                ${isInProgress ? '<div class="auto-scroll-indicator">Auto-scroll</div>' : ''}
              </div>
            `;

            // Insert at correct position
            const allDetails = stagesContainer.querySelectorAll('details');
            if (index < allDetails.length) {
              stagesContainer.insertBefore(newStage, allDetails[index]);
            } else {
              stagesContainer.appendChild(newStage);
            }

            // Add toggle handler
            newStage.addEventListener('toggle', function() {
              saveDetailsState();

              if (this.open && isInProgress) {
                const stageContent = this.querySelector('.stage-content');
                if (stageContent) {
                  setTimeout(() => {
                    stageContent.scrollTop = stageContent.scrollHeight;
                    tailingStages.add(stage.name);
                    attachScrollHandlers(stageContent, stage.name, isInProgress);
                  }, 50);
                }
              }
            });
          }
        });

        // Remove stages that no longer exist
        existingStages.forEach(stage => stage.remove());

        // Restore open state
        restoreDetailsState();
        updateLastUpdateTime();

        // Ensure scroll handlers are attached to all open stages
        document.querySelectorAll('details[open]').forEach(details => {
          const stageName = details.getAttribute('data-stage-name');
          const stageStatus = details.getAttribute('data-stage-status');
          const stageContent = details.querySelector('.stage-content');
          const isInProgress = stageStatus === 'in_progress' || stageStatus === 'running';

          if (stageContent && stageName) {
            attachScrollHandlers(stageContent, stageName, isInProgress);
          }
        });
      }

      // Socket.IO event handlers
      socket.on('connect', () => {
        console.log('Connected to WebSocket server');
        updateConnectionStatus(true);
      });

      socket.on('disconnect', () => {
        console.log('Disconnected from WebSocket server');
        updateConnectionStatus(false);
      });

      socket.on('pipeline_update', (data) => {
        console.log('Received pipeline update', data);
        updatePipeline(data);
      });

      // Build selector change handler
      buildSelect.addEventListener('change', (e) => {
        const selectedRunId = e.target.value;
        socket.emit('switch_build', { runId: selectedRunId });
      });

      // New build alert click handler
      newBuildAlert.addEventListener('click', () => {
        // Switch to latest build
        if (buildSelect.options.length > 0) {
          buildSelect.selectedIndex = 0;
          buildSelect.dispatchEvent(new Event('change'));
        }
        newBuildAlert.classList.remove('show');
      });

      // Manual refresh button (Ctrl/Cmd + R)
      document.addEventListener('keydown', (e) => {
        if (e.key === 'r' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          socket.emit('request_update');
        }
      });

      // Initialize
      updateLastUpdateTime();
      updateStageDurations();

      // Populate initial build selector
      const initialRuns = {{ recentRuns | tojson }};
      if (initialRuns && initialRuns.length > 0) {
        updateBuildSelector(initialRuns, currentRunId);
      }

      // Add handlers to existing elements
      document.querySelectorAll('details').forEach(details => {
        const stageName = details.getAttribute('data-stage-name');
        const stageStatus = details.getAttribute('data-stage-status');
        const isInProgress = stageStatus === 'in_progress' || stageStatus === 'running';

        details.addEventListener('toggle', function() {
          saveDetailsState();

          if (this.open && isInProgress) {
            const stageContent = this.querySelector('.stage-content');
            if (stageContent) {
              setTimeout(() => {
                stageContent.scrollTop = stageContent.scrollHeight;
                tailingStages.add(stageName);
                attachScrollHandlers(stageContent, stageName, isInProgress);
              }, 50);
            }
          }
        });

        // If already open and in progress, set up tailing
        if (details.open && isInProgress) {
          const stageContent = details.querySelector('.stage-content');
          if (stageContent) {
            stageContent.scrollTop = stageContent.scrollHeight;
            tailingStages.add(stageName);
            attachScrollHandlers(stageContent, stageName, isInProgress);
          }
        }
      });
    </script>
  </body>
</html>
